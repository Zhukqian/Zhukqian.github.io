---
layout:     post
title:      美团 Java 最新面试题-详细讲解
subtitle:   高并发
date:       2019-11-1
author:     朱坤乾
header-img: ![]()
catalog: true
tags:
    - 面试题
---
###  1:ArrayList 和 Vector 的区别。

这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。

二者都有一个初始容量大小，采用线性连续存储空间；当Vector或ArrayList中的元素超过它的初始大小时，Vector会将它的容量翻倍，而ArrayList只增加50%的大小，这样ArrayList就有利于节约内存空间。

Vector的方法都是同步的，是线程安全的，而ArrayList的方法不是,多线程中使用不安全.再多线程中某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。

ArrayList采用动态对象数组实现，默认构造方法创建了一个空数组.Vector采用动态数组对象实现，默认构造方法创建了一个大小为10的对象数组


###  2:说说 ArrayList,Vector, LinkedList 的存储性能和特性。

ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，
但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据效率较低，

Vector由于使用了synchronized（同步）方法（线程安全），通常性能上较ArrayList差。但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用

LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。

LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用


###  3:快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？

一：快速失败（fail—fast） 

在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。

原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。 

注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。 

场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。 

二：安全失败（fail—safe） 

采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。

      原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。

      缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。

      场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。

###  4:hashmap 的数据结构。

JDK&之前的HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。

jdk8后采用数组+链表+红黑树的数据结构。我们通过put和get存储和获取对象。当我们给put()方法传递键和值时，先对键做一个hashCode()的计算来得到它在bucket数组中的位置来存储Entry对象。当
获取对象时，通过get获取到bucket的位置，再通过键对象的equals()方法找到正确的键值对，然后在返回值对象。

JDK8中,HashMap采用的是位桶+链表/红黑树的方式,当链表的存储的数据个数大于等于8的时候，不再采用链表存储，而采用了红黑树存储结构。

###  5:HashMap 的工作原理是什么?

HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，
它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，
然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。

###  6:Hashmap 什么时候进行扩容呢？

首先要了解HashMap的扩容过程，我们就得了解一些HashMap中的变量：

    Node<K,V>：链表节点，包含了key、value、hash、next指针四个元素
    table：Node<K,V>类型的数组，里面的元素是链表，用于存放HashMap元素的实体
    size：记录了放入HashMap的元素个数
    loadFactor：负载因子
    threshold：阈值，决定了HashMap何时扩容，以及扩容后的大小，一般等于table大小乘以loadFactor

HashMap使用的是懒加载，构造完HashMap对象后，只要不进行put 方法插入元素之前，HashMap并不会去初始化或者扩容table

调用场景：

1.初始化数组table

2.当数组table的size达到阙值时即++size > load factor * capacity 时，也是在putVal函数中

实现过程：(细讲)

1.通过判断旧数组的容量是否大于0来判断数组是否初始化过

否：进行初始化

    判断是否调用无参构造器，
        是:使用默认的大小和阙值
        否:使用构造函数中初始化的容量，当然这个容量是经过tableSizefor计算后的2的次幂数

是，进行扩容，扩容成两倍(小于最大值的情况下)，之后在进行将元素重新进行与运算复制到新的散列表中

概括的讲：扩容需要重新分配一个新数组，新数组是老数组的2倍长，然后遍历整个老结构，把所有的元素挨个重新hash分配到新结构中去。

PS：可见底层数据结构用到了数组，到最后会因为容量问题都需要进行扩容操作


###  7:List、Map、Set 三个接口，存取元素时，各有什么特点？

List与Set都是单列元素的集合，它们有一个功共同的父接口Collection。

Set里面不允许有重复的元素，

存元素：add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true；当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。

取元素：没法说取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。

 

List表示有先后顺序的集合，

存元素：多次调用add(Object)方法时，每次加入的对象按先来后到的顺序排序，也可以插队，即调用add(int index,Object)方法，就可以指定当前对象在集合中的存放位置。

取元素：方法1：Iterator接口取得所有，逐一遍历各个元素

        方法2：调用get(index i)来明确说明取第几个。

 

Map是双列的集合，存放用put方法:put(obj key,obj value)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。

取元素：用get(Object key)方法根据key获得相应的value。

        也可以获得所有的key的集合，还可以获得所有的value的集合，

        还可以获得key和value组合成的Map.Entry对象的集合。

 

List以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value值，value可多值。

###  8:Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用 == 还是 equals()? 它们有何区别?

Set 里的元素是不能重复的，元素重复与否是使用 equals()方法进行判断的。

equals()和==方法决定引用值是否指向同一对象 equals()在类中被覆盖，为的是当两个
分离的对象的内容和类型相配的话，返回真值。

###  9:两个对象值相同 (x.equals(y) == true)，但却可有不同的 hash code，这句话对不对?

不对，如果两个对象x 和 y 满足 x.equals(y) == true，它们的哈希码（hashCode）应当相同。

Java 对于eqauls 方法和 hashCode 方法是这样规定的：

(1)如果两个对象相同（equals 方法返回 true），那么它们的hashCode 值一定要相同；

(2)如果两个对象的 hashCode 相同，它们并不一定相同。

###  10:heap 和 stack 有什么区别。

1:从存储方面来看堆内存主要存实例对象和jre classes      栈内存主要用于存储基本变量和对象引用

2:从存取速度来看的话,栈存储快,堆存储比较慢,因要要在运行时动态分配内存

3:从线程角度来看,每一个线程都有一个自己的java栈,所有线程共享一个java堆

4:从GC来看,栈区GC比较频繁,堆区不频繁























